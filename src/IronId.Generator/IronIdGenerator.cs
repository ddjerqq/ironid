using System;
using System.Diagnostics;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;

namespace IronIdGenerator;

[Generator]
public sealed class IronIdGenerator : IIncrementalGenerator
{
    private const string GeneratedCodeNamespace = "IronId.Generated";
    private const string GeneratedCodeAttribute = $"""[global::System.CodeDom.Compiler.GeneratedCodeAttribute("IronIdGenerator.IronIdGenerator", "{Version.Current}")]""";

    private const string CommonSrc =
        $$"""
          // <auto-generated/>
          #pragma warning disable
          #nullable enable

          using System.Linq;

          namespace {{GeneratedCodeNamespace}};

          /// <summary>
          /// Marker interface that all generated Strong ID types implement.
          /// Provides methods necessary for universal conversion in ORMs like Entity Framework Core.
          /// </summary>
          {{GeneratedCodeAttribute}}
          public interface IIronId
          {
              /// <summary>
              /// Gets the string representation of this IronId.
              /// </summary>
              string ToString();
              
              /// <summary>
              /// Gets the underlying Ulid value.
              /// </summary>
              global::System.Ulid GetValue();
          }

          /// <summary>
          /// Marks a class as an IronId type with the specified prefix.
          /// </summary>
          /// <param name="prefix">Required prefix for the IronId type.</param>
          {{GeneratedCodeAttribute}}
          [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
          public sealed class IronIdAttribute(string prefix) : global::System.Attribute
          {
              /// <summary>
              /// Required prefix for the IronId type.
              /// </summary>
              public string Prefix { get; set; } = prefix;
          }

          /// <summary>
          /// Helper methods for configuring IronId converters.
          /// </summary>
          {{GeneratedCodeAttribute}}
          public static class IronIdExtensions
          {
              /// <summary>
              /// Gets all IronId types in the assembly.
              /// </summary>
              public static IEnumerable<Type> IdTypes = typeof(IIronId).Assembly.GetTypes().Where(x => typeof(IIronId).IsAssignableFrom(x));

              /// <summary>
              /// Automatically registers all generated IronId JSON converters.
              /// This is typically not needed since IronIds have [JsonConverter] attributes,
              /// but can be useful for custom JsonSerializerOptions configuration.
              /// </summary>
              /// <example>
              /// var options = new JsonSerializerOptions();
              /// options.Converters.ConfigureIronIdConverters();
              /// </example>
              public static void ConfigureIronIdConverters(this global::System.Collections.Generic.IList<global::System.Text.Json.Serialization.JsonConverter> converters)
              {
                  var assembly = typeof(IIronId).Assembly;

                  var converterTypes =
                      from global::System.Type type in assembly.GetTypes()
                      let baseType = type.BaseType
                      where baseType?.IsGenericType == true
                      where baseType.GetGenericTypeDefinition() == typeof(global::System.Text.Json.Serialization.JsonConverter<>)
                      let idType = baseType.GetGenericArguments()[0]
                      where typeof(IIronId).IsAssignableFrom(idType)
                      select type;

                  foreach (var converterType in converterTypes)
                  {
                      var converter = global::System.Activator.CreateInstance(converterType) as global::System.Text.Json.Serialization.JsonConverter;
                      if (converter is not null)
                          converters.Add(converter);
                  }
              }

              /// <summary>
              /// Parses the given string into the appropriate IronId type based on its prefix.
              /// </summary>
              public static IIronId Parse(string s)
              {
                  foreach (var idType in IdTypes)
                  {
                      var parseMethod = idType.GetMethod("Parse", new[] { typeof(string), typeof(global::System.IFormatProvider) });
                      if (parseMethod is not null)
                      {
                          try
                          {
                              var result = parseMethod.Invoke(null, new object?[] { s, null });
                              if (result is not null)
                                  return (IIronId)result;
                          }
                          catch (global::System.Reflection.TargetInvocationException)
                          {
                              // Ignore and try next
                          }
                      }
                  }

                  throw new global::System.FormatException($"No matching IronId type found for value: {s}");
              }
          }
          """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource($"{GeneratedCodeNamespace}.g.cs", CommonSrc));
        
        var syntaxProvider = context.SyntaxProvider
            .CreateSyntaxProvider(SyntacticPredicate, SemanticTransform)
            .Where(static type => type is not null)
            .Select(EntityIronIdContext.FromEntityTypeInfo!)
            .WithComparer(PartialClassContextEqualityComparer.Instance);

        context.RegisterSourceOutput(syntaxProvider, Execute);
    }

    private static bool SyntacticPredicate(SyntaxNode node, CancellationToken _) => node switch
    {
        ClassDeclarationSyntax { AttributeLists.Count: > 0 } classDeclarationSyntax =>
            classDeclarationSyntax.AttributeLists.Any(static attr =>
                attr.Attributes.Any(static a => a.Name.ToString() == "IronId")),
        RecordDeclarationSyntax { AttributeLists.Count: > 0 } recordDeclarationSyntax =>
            recordDeclarationSyntax.AttributeLists.Any(static attr =>
                attr.Attributes.Any(static a => a.Name.ToString() == "IronId")),
        _ => false,
    };

    private static INamedTypeSymbol? SemanticTransform(GeneratorSyntaxContext context, CancellationToken ct)
    {
        Debug.Assert(context.Node is ClassDeclarationSyntax or RecordDeclarationSyntax);

        TypeDeclarationSyntax candidate = context.Node switch
        {
            ClassDeclarationSyntax => Unsafe.As<ClassDeclarationSyntax>(context.Node),
            RecordDeclarationSyntax => Unsafe.As<RecordDeclarationSyntax>(context.Node),
            _ => throw new Exception("IronIdAttribute found on something that is neither a record or a class"),
        };

        if (context.SemanticModel.GetDeclaredSymbol(candidate, ct) is { } entityType)
        {
            var strongIdAttribute = context.SemanticModel.Compilation.GetTypeByMetadataName($"{GeneratedCodeNamespace}.IronIdAttribute");
            if (strongIdAttribute is not null)
                return entityType as INamedTypeSymbol;
        }

        return null;
    }
    
    private static void Execute(SourceProductionContext context, EntityIronIdContext subject)
    {
        var idClassName = $"{subject.TypeName}Id";
        var converterClassName = $"{idClassName}JsonConverter";

        var idSource = $$"""
                         // <auto-generated/>
                         #pragma warning disable
                         #nullable enable

                         namespace {{subject.Namespace}};

                         /// <summary>
                         /// Represents a {{idClassName}} Iron ID type. Uses prefix "{{subject.Prefix}}".
                         /// To create a new instance, use {{idClassName}}.New().
                         /// </summary>
                         /// <param name="Value">The Ulid value from which to construct this Id</param>
                         {{GeneratedCodeAttribute}}
                         [global::System.Text.Json.Serialization.JsonConverter(typeof({{converterClassName}}))]
                         [global::System.ComponentModel.TypeConverter(typeof({{idClassName}}TypeConverter))]
                         public readonly record struct {{idClassName}}(global::System.Ulid Value) : global::{{GeneratedCodeNamespace}}.IIronId, global::System.IComparable, global::System.IParsable<{{idClassName}}>
                         {
                             public const string Prefix = "{{subject.Prefix}}";
                             
                             public static readonly {{idClassName}} Empty = new(global::System.Ulid.Empty);
                             public static {{idClassName}} New() => new(global::System.Ulid.NewUlid());

                             public {{idClassName}}() : this(global::System.Ulid.NewUlid()) {}
                             
                             public override string ToString() => $"{Prefix}_{Value}".ToLower();
                             
                             /// <summary>
                             /// Gets the underlying Ulid value. Implements IIronId.GetValue().
                             /// </summary>
                             public global::System.Ulid GetValue() => Value;
                             public static {{idClassName}} Parse(string s, global::System.IFormatProvider? provider = default) => TryParse(s, provider, out var result) ? result : throw new global::System.FormatException();
                             public static bool TryParse([global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] string? s, global::System.IFormatProvider? provider, out {{idClassName}} result)
                             {
                                 result = default!;

                                 if (!string.IsNullOrWhiteSpace(s)
                                     && s.Split("_") is [.. var typeNameParts, var idValue]
                                     && string.Join('_', typeNameParts) is var typeName 
                                     && typeName.Equals(Prefix, global::System.StringComparison.OrdinalIgnoreCase)
                                     && global::System.Ulid.TryParse(idValue.ToUpperInvariant(), out var id))
                                 {
                                     result = new {{idClassName}}(id);
                                     return true;
                                 }

                                 return false;
                             }
                             
                             public static implicit operator string({{idClassName}} id) => id.ToString();
                             public static explicit operator {{idClassName}}(string id) => Parse(id);
                             
                             public static implicit operator global::System.Ulid({{idClassName}} id) => id.Value;
                             public static explicit operator {{idClassName}}(global::System.Ulid id) => new {{idClassName}}(id);
                             
                             public int CompareTo(object value)
                             {
                                 if (value == null) return 1;
                                 if (value is {{idClassName}} other) return this.Value.CompareTo(other.Value);
                                 throw new global::System.ArgumentException("Object must be of type {{idClassName}}.", nameof(value));
                             }
                         }

                         /// <summary>
                         /// System.Text.Json converter for {{idClassName}}.
                         /// </summary>
                         {{GeneratedCodeAttribute}}
                         public sealed class {{converterClassName}} : global::System.Text.Json.Serialization.JsonConverter<{{idClassName}}>
                         {
                             public override {{idClassName}} Read(ref global::System.Text.Json.Utf8JsonReader reader, global::System.Type typeToConvert, global::System.Text.Json.JsonSerializerOptions options)
                             {
                                 var value = reader.GetString();
                                 if (value is null)
                                     throw new global::System.Text.Json.JsonException($"Cannot deserialize null to {{idClassName}}.");
                                 
                                 if (!{{idClassName}}.TryParse(value, null, out var result))
                                     throw new global::System.Text.Json.JsonException($"Invalid {{idClassName}} format: {value}");
                                 
                                 return result;
                             }

                             public override void Write(global::System.Text.Json.Utf8JsonWriter writer, {{idClassName}} value, global::System.Text.Json.JsonSerializerOptions options)
                             {
                                 writer.WriteStringValue(value.ToString());
                             }
                         }


                         /// <summary>
                         /// System.ComponentModel.TypeConverter for {{idClassName}}.
                         /// Enables type conversion for ASP.NET Core model binding and other framework scenarios.
                         /// </summary>
                         {{GeneratedCodeAttribute}}
                         public sealed class {{idClassName}}TypeConverter : global::System.ComponentModel.TypeConverter
                         {
                             public override bool CanConvertFrom(global::System.ComponentModel.ITypeDescriptorContext? context, global::System.Type sourceType) =>
                                 sourceType == typeof(string) || base.CanConvertFrom(context, sourceType);

                             public override object? ConvertFrom(global::System.ComponentModel.ITypeDescriptorContext? context, global::System.Globalization.CultureInfo? culture, object value) =>
                                 value is string str && {{idClassName}}.TryParse(str, culture, out var id) ? id : base.ConvertFrom(context, culture, value);

                             public override bool CanConvertTo(global::System.ComponentModel.ITypeDescriptorContext? context, global::System.Type? destinationType) =>
                                 destinationType == typeof(string) || base.CanConvertTo(context, destinationType);

                             public override object? ConvertTo(global::System.ComponentModel.ITypeDescriptorContext? context, global::System.Globalization.CultureInfo? culture, object? value, global::System.Type destinationType) =>
                                 destinationType == typeof(string) && value is {{idClassName}} id ? id.ToString() : base.ConvertTo(context, culture, value, destinationType);
                         }
                         """;

        context.AddSource($"IronId.Generated.{idClassName}.g.cs", idSource);
    }
}
